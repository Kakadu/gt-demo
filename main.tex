%% For double-blind review submission, w/o CCS and ACM Reference (max submission space)
\documentclass[acmsmall,review,anonymous]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
%% For double-blind review submission, w/ CCS and ACM Reference
%\documentclass[acmsmall,review,anonymous]{acmart}\settopmatter{printfolios=true}
%% For single-blind review submission, w/o CCS and ACM Reference (max submission space)
%\documentclass[acmsmall,review]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
%% For single-blind review submission, w/ CCS and ACM Reference
%\documentclass[acmsmall,review]{acmart}\settopmatter{printfolios=true}
%% For final camera-ready submission, w/ required CCS and ACM Reference
%\documentclass[acmsmall]{acmart}\settopmatter{}


%% Journal information
%% Supplied to authors by publisher for camera-ready submission;
%% use defaults for review submission.
\acmJournal{PACMPL}
\acmVolume{1}
\acmNumber{CONF} % CONF = POPL or ICFP or OOPSLA
\acmArticle{1}
\acmYear{2017}
\acmMonth{1}
\acmDOI{} % \acmDOI{10.1145/nnnnnnn.nnnnnnn}
\startPage{1}

%% Copyright information
%% Supplied to authors (based on authors' rights management selection;
%% see authors.acm.org) by publisher for camera-ready submission;
%% use 'none' for review submission.
\setcopyright{none}
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
%\setcopyright{rightsretained}
%\copyrightyear{2017}           %% If different from \acmYear

%% Bibliography style
\bibliographystyle{ACM-Reference-Format}
%% Citation style
%% Note: author/year citations are required for papers published as an
%% issue of PACMPL.
\citestyle{acmauthoryear}   %% For author/year citations


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Note: Authors migrating a paper from PACMPL format to traditional
%% SIGPLAN proceedings format must update the '\documentclass' and
%% topmatter commands above; see 'acmart-sigplanproc-template.tex'.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%% Some recommended packages.
\usepackage{booktabs}   %% For formal tables:
                        %% http://ctan.org/pkg/booktabs
\usepackage{subcaption} %% For complex figures with subfigures/subcaptions
                        %% http://ctan.org/pkg/subcaption
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
% \usepackage[english]{babel}

\usepackage{amsmath,amssymb}
\usepackage{listings}
\usepackage{amsmath,amssymb}

% macro to select a scaled-down version of Bera Mono (for instance)
\makeatletter
\newcommand\BeraMonottfamily{%
  \def\fvm@Scale{0.85}% scales the font down
  \fontfamily{fvm}\selectfont% selects the Bera Mono font
}
\makeatother

\def\backtick{\char18}
\renewcommand{\ttdefault}{cmtt}
% \renewcommand{\ttdefault}{lmtt}
\newcommand*{\ttfamilywithbold}{\fontfamily{cmuntb}\selectfont}

\lstdefinelanguage{ocaml}{
keywords={fresh, conde, let, begin, end, in, match, type, and, fun, function,
try, with, when, class, object, method, of, rec, nonrec, repeat, until, 
while, not, do, done, as, val, inherit, new, module, sig, deriving, datatype,
struct, if, then, else, open, private, virtual, include, @type
},
sensitive=true,
basicstyle=\ttfamily,
commentstyle=\itshape\ttfamily,
keywordstyle=\bfseries\ttfamily\bfseries\underbar,
% keywordstyle=\ttfamilywithbold\underbar,
identifierstyle=\ttfamily,
basewidth={0.5em,0.5em},
columns=fixed,
fontadjust=true,
literate={`}{$\backtick$}1 {->}{{$\to\;\;$}}3 {===}{{$\equiv$}}3 {=/=}{{$\not\equiv$}}3 {|>}{{$\triangleright$}}3,
morecomment=[s]{(*}{*)}
}

\lstset{
mathescape=true,
identifierstyle=\ttfamily,
keywordstyle=\bfseries,
commentstyle=\scriptsize\rmfamily,
basewidth={0.5em,0.5em},
fontadjust=true,
language=ocaml
}
\let\listinline\lstinline

% \usepackage{minted}
% \usemintedstyle{rrt}

\begin{document}

%% Title information
\title[Short Title]{Full Title}         %% [Short Title] is optional;
                                        %% when present, will be used in
                                        %% header instead of Full Title.
\titlenote{with title note}             %% \titlenote is optional;
                                        %% can be repeated if necessary;
                                        %% contents suppressed with 'anonymous'
\subtitle{Subtitle}                     %% \subtitle is optional
\subtitlenote{with subtitle note}       %% \subtitlenote is optional;
                                        %% can be repeated if necessary;
                                        %% contents suppressed with 'anonymous'


%% Author information
%% Contents and number of authors suppressed with 'anonymous'.
%% Each author should be introduced by \author, followed by
%% \authornote (optional), \orcid (optional), \affiliation, and
%% \email.
%% An author may have multiple affiliations and/or emails; repeat the
%% appropriate command.
%% Many elements are not rendered, but should be provided for metadata
%% extraction tools.

%% Author with single affiliation.
\author{First1 Last1}
\authornote{with author1 note}          %% \authornote is optional;
                                        %% can be repeated if necessary
\orcid{nnnn-nnnn-nnnn-nnnn}             %% \orcid is optional
\affiliation{
  \position{Position1}
  \department{Department1}              %% \department is recommended
  \institution{Institution1}            %% \institution is required
  \streetaddress{Street1 Address1}
  \city{City1}
  \state{State1}
  \postcode{Post-Code1}
  \country{Country1}                    %% \country is recommended
}
\email{first1.last1@inst1.edu}          %% \email is recommended

%% Author with two affiliations and emails.
\author{First2 Last2}
\authornote{with author2 note}          %% \authornote is optional;
                                        %% can be repeated if necessary
\orcid{nnnn-nnnn-nnnn-nnnn}             %% \orcid is optional
\affiliation{
  \position{Position2a}
  \department{Department2a}             %% \department is recommended
  \institution{Institution2a}           %% \institution is required
  \streetaddress{Street2a Address2a}
  \city{City2a}
  \state{State2a}
  \postcode{Post-Code2a}
  \country{Country2a}                   %% \country is recommended
}
\email{first2.last2@inst2a.com}         %% \email is recommended
\affiliation{
  \position{Position2b}
  \department{Department2b}             %% \department is recommended
  \institution{Institution2b}           %% \institution is required
  \streetaddress{Street3b Address2b}
  \city{City2b}
  \state{State2b}
  \postcode{Post-Code2b}
  \country{Country2b}                   %% \country is recommended
}
\email{first2.last2@inst2b.org}         %% \email is recommended


%% Abstract
%% Note: \begin{abstract}...\end{abstract} environment must come
%% before \maketitle command
\begin{abstract}
Text of abstract \ldots.
\end{abstract}


%% 2012 ACM Computing Classification System (CSS) concepts
%% Generate at 'http://dl.acm.org/ccs/ccs.cfm'.
\begin{CCSXML}
<ccs2012>
<concept>
<concept_id>10011007.10011006.10011008</concept_id>
<concept_desc>Software and its engineering~General programming languages</concept_desc>
<concept_significance>500</concept_significance>
</concept>
<concept>
<concept_id>10003456.10003457.10003521.10003525</concept_id>
<concept_desc>Social and professional topics~History of programming languages</concept_desc>
<concept_significance>300</concept_significance>
</concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Software and its engineering~General programming languages}
\ccsdesc[300]{Social and professional topics~History of programming languages}
%% End of generated code


%% Keywords
%% comma separated list
\keywords{datatype-generic programming, object-oriented programming, code reuse}
%% \keywords are mandatory in final camera-ready submission


%% \maketitle
%% Note: \maketitle command must come after title commands, author
%% commands, abstract environment, Computing Classification System
%% environment and commands, and keywords command.
\maketitle


%\section{Introduction}

%Text of paper \ldots


%% Acknowledgments
\begin{acks}                            %% acks environment is optional
                                        %% contents suppressed with 'anonymous'
  %% Commands \grantsponsor{<sponsorID>}{<name>}{<url>} and
  %% \grantnum[<url>]{<sponsorID>}{<number>} should be used to
  %% acknowledge financial support and will be used by metadata
  %% extraction tools.
  This material is based upon work supported by the
  \grantsponsor{GS100000001}{National Science
    Foundation}{http://dx.doi.org/10.13039/100000001} under Grant
  No.~\grantnum{GS100000001}{nnnnnnn} and Grant
  No.~\grantnum{GS100000001}{mmmmmmm}.  Any opinions, findings, and
  conclusions or recommendations expressed in this material are those
  of the author and do not necessarily reflect the views of the
  National Science Foundation.
\end{acks}

% \section{Regularity and non-regularity}
% In a regular datatype declaration, occurrences of the declared type on the right-hand
% side  of  the  defining  equation  are  restricted  to  copies  of  the  left-hand  side,  so
% the recursion  is "tail recursive"
% \footnote{from http://www.cs.ox.ac.uk/richard.bird/online/BirdMeertens98Nested.pdf}.
% 
% For example the \lstinline{type ('a,'b) t = A | B of ('a, int) t} is non-regular and we need to use
% \textit{polymorphic recursion} to iterate over it. Without explicit annotation the iteration
% function will have the wrong type.
% \begin{lstlisting}
% # let rec iter: 'a 'b . ('a, 'b) t -> unit = function A -> () | B x -> iter x;;
% val iter : ('a, 'b) t -> unit = <fun>
% # let rec iter = function A -> () | B x -> iter x;;
% val iter : ('a, int) t -> unit = <fun>
% \end{lstlisting}
% In that particular case unfolding can help to do what we want without explicit type annotations
% \begin{lstlisting}
% let rec iter = function A -> () | B x -> iter x;;
% let iter = function A -> () | B x -> iter x;;
% \end{lstlisting}

% \section{WTF we are doing this}
% Say about inheritance, \lstinline{ppx_visitors}, ineritance problem for type aliases, grammar-like intuition: inherited and synthesized attributes, triples of type parameters

\section{Sorts of types}
% $\overline{remark~how~to~write~upper~line}$
% 
% \[
% \underbrace{u'-P(x)u^2-Q(x)u-R(x)}_{\text{=0, since~$u$ is a particular solution.}}
% I_{2,(\underbrace{\scriptstyle3,3,3,3,3}_5)}
% \]

\begin{lstlisting}[language=ocaml]
type ($a_1$, ..., $a_n$) typename =
  (* primitive ones *)
  | int | string | ...
  (* named aliases *)
  | type_ as 'identifier
  (* constructors of algebraic types *)
  | $C_1$ of $t_{11}$ * ... * $t_{1 n_1}$ | ... | $C_k$ of $t_{k1}$ * ... * $t_{k n_k}$
  (* constructors with records *)
  | $C_1$ of { $f_{11}$=$t_{11}$; ...; $e_{1 n_1}$=$t_{1 n_1}$} | ... | $C_k$ of { $f_{k1}$=$t_{k1}$;  ...; $f_{k n_k}$=$t_{k n_k}$ }
  (* tuples can be viewed as specific predefined constructors *)
  | ($t_1$, ..., $t_k$)
  (* polymorphic variants with concrete constructors  *)
  | [ `$C_1$ of $t_{11}$ * ... * $t_{1 n_1}$ | ... | `$C_k$ of $t_{k1}$ * ... * $t_{k n_k}$ ] 
  (* union of polymorphic variants *)
  | [ ($t_{1}$,...,$t_{l}$) $\tau$ | ... ]
  (* type abbrevations (a.k.a. type aliases, type operators) *)
  | ($t_1$, ..., $t_n$) $\tau$
\end{lstlisting}
Current limitations:
\begin{itemize}
 \item Only regular type definitions.
 \item Constraints on type declarations are not being taken to account.
 \item GADTs are treated as simple algebraic data types.
 \item Using object types, module types and functional types in type declarations is not supported (but hackable).
 \item \verb=nonrec= keyword is not taken to account.
\end{itemize}


\section{Какие объявления генерируются по объявлению типа}

Для каждого объявления типа \lstinline{type ($a_1$, ..., $a_n$) t} генерируются в файле реализации:
\begin{itemize}
 \item \textit{Interface class} который определяет тип всех трансформаций, которые могут быть применены для значения типа \lstinline{t}.
 \item \textit{Generic catamorphism}, который позволяет применить конкретную трансформациюю к значению типа \lstinline{t}.
\end{itemize}

А также два соответсвующих объявления в файле интерфейса.


Для каждого вида трансформации типа \lstinline{type ($a_1$, ..., $a_n$) t} в файле реализации генерируется:
\begin{itemize}
 \item \textit{Класс трансформации}, который наследует interface class, принимает функции-трансформации аргементов в момент конструирования и 
	определяет как именно осуществляется трансформация для значения типа \lstinline{type ($a_1$,...,$a_n$) t}.
 \item Функция трансформации для \lstinline{type ($a_1$, ..., $a_n$) t}, которая принимает функции-трансформации аргументов, инстанциирует
	класс трансформации и применяет трансформацию.
\end{itemize}
Аналогично, два объявления в файле интерфейса.

Чтобы сгенерировать реализицию некоторого вида трансформации для \lstinline{type ($a_1$, ..., $a_n$) t}, необходимо в пространстве имениметь 
трасформации для всех типов, которые входят в RHS объявления типа. Если же объявление типа является type abbrevation (т.е. 
 \lstinline{type ($a_1$, ..., $a_n$) t = ($b_1$, ..., $b_m$) $\tau$} или для полиморфных вариантов 
 \lstinline{type ($a_1$, ..., $a_n$) t = [ ($b_1$, ..., $b_m$) $\tau$ | ... ]}) 
 то, дополнительно необходимо иметь класс трансформации для типа
 $\tau$.

Все классы трансформации принимают (n+1) параметров: одна функция трансформации рекурсивного вхождения объявления типа 
(здесь мы сужаем множество поддерживаемых определений типов только до регулярных) и функции-трансформации для типовых параметров. Для процесса
генерации является существенным, чтобы все классы, определяющие трансформацию, имели сходную сигнатуру, выводимую только из имени типа 
и количества его параметров. Поэтому, функцию-трансформацию рекурсивного вхождения типа нельзя опустить для нерекурсивных типов.

Для взаимно-рекурсивных определений типов затруднительно иметь трансформацию для всех объявляемых типов в момент объявления класса 
трансформации (OCaml не поддерживает взаимно-рекурсивные определения между классами и функциями). Поэтому в файле реализации 
для каждого объявления типа генерируются два класса, где первый имеет дополнительные параметры для функций-трансформаций
взаимно-рекурсивных определений. После определения функций-трансформаций для объявляемых типов генерируются ещё несколько классов,
которые наследуют предыдущие определения, конкретизируя функции-трансформации для объявляемых взаимно-рекурсивных типов. 
Таким образом, все сгенерированные классы для взаимно-рекурсивных определений имеют такую же форму в сигнатуре, как и классы для
одиночных определений типов.

В GT также поддерживаются объявление полиморфных вариантов, которые оказывают влияние на форму сигнатуры всех генерируемых классов.
Для поддержки возможности объединения полиморфных вариантов при объявлении типа все классы имеют дополнительный параметр, который 
является свободной типовой переменной в случае класса для обычных объявлений типов, и является \textit{открытой} версией типа если класс 
соответствует полиморфному вариантному типу. Также, полиморфный вариантный тип требует дополнительных аннотаций открытости при объявлении
сигнатуры функции-трансформации для трасформации вида \verb=gmap= (a.k.a. functor).

\section{Что конкретно генерируется для разных объявлений типов}

\subsection{Одиночные объявления (без взаимной рекурсии) }
В этом разделе описывается результат генерации кода для одиночных (возможно, рекурсивных) определений типов

\lstinline{type ($a_1$, ..., $a_n$) $\tau$ = $\xi$}


\begin{itemize}
  \item В \textit{interface class} для типа \lstinline{$\tau$} методы соответствуют конструкторам алгебраического типа или полиморфного варианта. 
  \begin{lstlisting}
  class virtual [ $class~type~params$ ] class_t = object
      ...
  end
  \end{lstlisting}
  Для type abbrevation's \lstinline{type ($a_1$, ..., $a_n$) $\tau$ = ($t_1$, ..., $t_n$) ab} 
  используется наследование, чтобы объявить класс : 
  \begin{lstlisting}
  class virtual [ $class~arguments$ ] class_$\tau$ = object
    inherit [$with~application\!-\!specific~arguments$] class_ab
  end
  \end{lstlisting}

  For every $n$-parametric type ($n>=0$) there are $3*n+2+1$ \emph{class arguments}. They are:
    \begin{center}
        $\overline{'ia_i, 'a_i, 'sa_i}$, $'inh$, $'extra$, $'syn$
    \end{center}
  where \begin{itemize}
          \item $'a_i$ is an $i$-th parameter of the type being processed;
          \item $'sa_i$ is a synthesized attribute for type parameter $a_i$;
          \item $'ia_i$ is an inherited attribute for type parameter $a_i$;
          \item $'inh$ is an inherited attribute for whole type $\xi$;
          \item $'extra$ -- если сейчас генерируется код для полиморфного варианта, то это открытый тип для $\xi$. Иначе, данный типовый параметр не используется по существу.
          \item $'syn$ is a synthesized attribute for the whole type.
  \end{itemize}
  
  \paragraph{}
  N.B. Although there some differences for type declarations that involve mutual recursion.
  
  \item \emph{Generic catamorphism} (для объявления типа $\tau$) под названием $gcata_\tau$, который принимает объект-трансформацию, начальный наследуемый атрибут $i$, значение типа $\tau$ и применяет трансформацию над $i$ и значением типа $\tau$. It is defined using pattern-matching for the variant types or as a composition with generic catamorphism $gcata_\tau$ if type $t$ is constructed as an application of type $\tau$.
  \item Для каждого вида трансформации $trait$ генерируется не виртуальный класс с реализацией этой трансформации:

  \begin{lstlisting}
  class [ $trait~class~arguments$ ] $trait$_$\xi$_t $\overline{f\!a_i}$ $f\!self$ = object
    inherit [ $inherited~class~arguments$ ] class_t
    (* implementation of virtual methods if any *)
  end
  \end{lstlisting}
  where \begin{itemize}
          \item transformation $f\!self$ is a current transformation; class is defined in open recursion style and will receive it after tying the knot
          \item $f\!a_i$ of type \lstinline{$ia_i$ -> $a_i$ -> $sa_i$} are transformation functions for type parameters;
          \item $'sa_i$ is a synthesized attribute for type parameter $a_i$;
          \item $'ia_i$ is an inherited attribute for type parameter $a_i$;
          \item $'syn$ is a synthesized attribute for the whole type.
  \end{itemize}
% \bigskip
%   TODO by Kakadu: I have strong feeling that $fa_i$ should have type \lstinline{$ia_i$ -> $a_i$ -> $sa_i$}. Motivating example will be a formatter plugin with \lstinline{'inh=== '$ia_i$ === Format.formatter} and \lstinline{'syn==='$sa_i$ === unit}.
  \item For every transformation $trait$ a \emph{transformation function} is being generated. It takes transformations $f\!a_i$ for every type parameter $a_i$, inherited attribute $inh$, a value of type $t$ that will be transformed and runts transformation specific for current trait.
  \begin{lstlisting}
let nonrec trait_$\tau$ $\overline{f\!a_i}$ inh subj =
  GT.transform_gc gcata_tree (new trait_$\tau$_t $\overline{f\!a_i}$) inh subj
  \end{lstlisting}  
\end{itemize}

\subsection{Взаимно рекурсивные определения}

Синтаксис взаимно рекурсивных определений:
\begin{lstlisting}
type ($a_{11}$, ..., $a_{m_1}$) $\tau_1$ = ... 
and  ($a_{21}$, ..., $a_{m_2}$) $\tau_2$ = ... 
...
and  ($a_{n1}$, ..., $a_{m_n}$) $\tau_n$ = ...
\end{lstlisting}

При генерации кода для взаимно рекурсивных определений типов происходит несколько усложнений по сравнению со случаем одиночных определений.

\begin{enumerate}
 \item Классу, реализующему трансформацию для типа $\tau_i$, необходимо иметь доступ к функциям-трансформацией типов $\tau_1,...,\tau_n$, объявленных взаимно рекурсивно с этим типом $\tau_i$. Таким образом, классы, реализующие трансформацию $trait$ для типа $\xi_i$, имеют дополнительные параметры ($f\!or\tau_{i}$) конструктора по сравнению с одиночным определением типа. Эти классы также имеют в имени суффикс $\_stub$.
 \begin{lstlisting}
 class [$class~type~params$] show_a_t_stub $\overline{for\tau_{i}}$ $\overline{f\!a_i}$ fself = 
   object  ...  end
\end{lstlisting}

 \item По взаимно рекурсивным определениям генерируется неподвижная точка, которая принимает функции для конструирования объектов-экземпляров классов $trait\_\tau_i\_t\_stub$, создает соответствующие объекты и возвращает $n$ функций-трансформаций для типов $\tau_i$ ($i=1..n$).

\begin{lstlisting}
let fix_a $\overline{c_{i}^{init}}$ =
  let rec $trait_1$ $\overline{f_{m1}}$ i s = gcata_a ($c_{1}^{init}$ $\overline{trait_i}$ $\overline{f_{m1}}$ $trait_1$) i s
  ...
  and     $trait_n$ $\overline{f_{mn}}$ i s = gcata_b ($c_{n}^{init}$ $\overline{trait_i}$ $\overline{f_{mn}}$ $trait_n$) i s 
  in
  $trait_1$, ..., $trait_1$
\end{lstlisting}
 
 \item Генерируется $n$ функций-трансформаций для типов $\tau_i$ с сигнатурами аналогичными одиночному случаю. Телами этих функций являются соответствующие вызовы неподвижной точки.
\begin{lstlisting}
let trait_$\tau_i$ eta = 
   let ($f_1$, ..., $f_i$, ..., $f_n$) = 
     fix_a (new trait_$\tau_1$_t_stub) ... (new trait_$\tau_n$_t_stub) in
   $f_i$ eta
\end{lstlisting} 

 \item Генерируются $n$ классов, реализующих трансформацию вида $trait$ для типов $\tau_i$. Они получаются путём специализации 
 классов, построенных в пункте 2, функциями-трансформациями из шага 3.
 \begin{lstlisting}
class [$class~type~params$] trait_$\tau_i$_t $\overline{f\!a_i}$ fself = object 
  inherit [$class~type~params$] trait_$\tau_i$_t_stub $\overline{trait\_\tau_i}$ $\overline{f\!a_i}$ fself
end
\end{lstlisting} 
По типу, полученного на данном шаге класса, невозможно понять, являлся ли он частью какого-то взаимно-рекурсивного набора типов или
нет, т.е. типы генерируемых классов выглядят единообразно. Следовательно, его можно безопасно использовать в остальной части программы, если он будет встречаться в других объявлениях типов.
\end{enumerate}


\section{Construction blocks for a transformation function}
A class declaration for transformation trait of of type $(a_1,...,a_n) t$ requires transformations of type parameters $a_i$; these transformation functions will be passed as arguments of class's constructor $trait\_t\_t$.

For all types that was used in declaration of type $t$ we suppose that transformation functions are present in the scope where the type $t$ is declared. As we declare class for transformation object just after type declaration, these functions will be in scope of type declaration too.

For recursive type declaration it is required to call a transformation function for this type inside the class that represents a transformation and will be used to construct this transformations function. OCaml language doesn't allow declaring mutually recusive functions and classes, so we break the recursion by explicitly passing self-transformation as one of constructor's arguments and tieing the knot later. 

% More precisely, if we have a recursive type 
% 
% \begin{lstlisting}
% type ('a, 'b) alist = ...
% type 'a list = ('a, 'a list) alist
% 
% class ['a, 'b] show_alist : 'self -> (unit -> 'a -> string) ->
%                                       (unit -> 'b -> string) ->
%   object
%     method c_Cons : unit -> 'a -> 'b -> string
%     method c_Nil  : unit -> string
%   end
% \end{lstlisting}
% 
% we add extra constructor argument \lstinline{self} to the declaration of class
% \begin{lstlisting}
% class ['a] show_list self fa = object
%   inherit ['a, unit, string, unit, string] class_list
%   inherit ['a, 'a list] show_alist "anything" fa self
% end
% \end{lstlisting}
% and use this function to specify a transformation of second argument during instantiation of the class \lstinline{show_alist}.

% \textbf{Note}. This \lstinline{self} argument is not admissable for nonrecursive types because we instantiate the class \lstinline{show_alist} by looking \textit{only} on application \lstinline{('a,'a list) alist} of this type in the definition of the type \lstinline{'a list}. This means that we know nothing about recursivity of the type \lstinline{('a,'b) alist} during the generation of transformations for the type \lstinline{'a list}.
% 
% This remark brings some complications when dealing with mutally recursive types \lstinline{$t_1$},...,\lstinline{$t_n$} where we need to declare two classes per every pair of type $t_i$ and transformation \lstinline{trans}. The first class \lstinline{trans_stub_$t_i$} for type \lstinline{$t_i$} will have $n-1$ extra constructor parameters for functional transformers that process types declared with \lstinline{$t_i$} recursively. Using this classes we can declare $n$ transformation functions for every type $t_i$. We abuse mutal recursion to make this transformation functions have the same interface that transformation functions for non-recursive types have. After declaring transformation functions we can declare transformation classes \lstinline{trans_$t_i$} with desired interface by partially applying constructors of \lstinline{trans_stub_$t_i$} to \lstinline{n-1} transformation functions.
  
% For an example with mutal recursion see \href{https://github.com/Kakadu/gt-demo/blob/master/src/demo05mutal.ml}{demo05} in the repository.

\section{About methods inside trait class (algebraic and records)}
\label{sec:methods}

Let us have a declaration
\begin{lstlisting}
type ($a_1$,...,$a_m$) $\tau$ = 
  type nonrec? ($a_1$, ..., $a_k$) typename =
    | $C_1$ of $t_{11}$ * ... * $t_{1n_1}$
    | $C_2$ of $t_{21}$ * ... * $t_{2n_2}$
    | ...
    | $C_m$ of $t_{m1}$ * ... *$t_{mn_m}$
\end{lstlisting}
In the interface class every constructor $C_i$ of algebraic data type is mapped to a single method of the class called $c\_C_i$ (lowercase c from ``constructor``). Each methods receives $2+n_1$ arguments: inherited attribute for a value of type $(...) \tau$, the value that is being transformed and $n_1$ other paramters that correspond to arguments of the constructor $C_i$. The same scheme is used for polymorphic variant types. Pitfalls related to polymorphic variants are described in \autoref{sec:polypitfalls}.

\begin{lstlisting}
class virtual [ $class~type~params$ ] class_t = object
  method virtual c_$C_i$: 'inh -> ($a_1$,...,$a_m$) $\tau$ -> $\overline{t_{in_i}}$ -> 'syn
end
\end{lstlisting}

Record types have essentially one (implicit) constructor, so only one method is being generated. Only two arguments are present because fields of the record are accessible using record pattern matching syntax
\begin{lstlisting}
type ($a_1$,...,$a_m$) $\tau$ = { $field_1$ : $typ_1$; ...; $field_n$ : $typ_n$  }
class virtual [ $class~type~params$ ] class_t = object
  method virtual do_$\tau$: 'inh -> ($a_1$,...,$a_m$) $\tau$ -> 'syn
end
\end{lstlisting}

\section{Polymorphic variant pitfalls}
\label{sec:polypitfalls}

\section{Issues with \listinline=nonrec= keyword}
\label{sec:nonrecpitfalls}

\section{Creating transformations for type aliases}
\label{sec:typealiases}
Let us have
\begin{lstlisting}
type ($a_1$,...,$a_m$)$\tau$ = ...
class virtual [$\overline{'a_i,'sa_i,'ia_i}$, $'inh$, $'self$, $'syn$] class_$\tau$ = object .. end
\end{lstlisting}
and want to generate transformations for the type
\begin{lstlisting}
type ($a_1$,...,$a_n$)t = ($b_1$,...,$b_m$)$\tau$ as 'smth
\end{lstlisting}
which is a \textit{type alias} of type $\tau$ with $m$ type arguments $b_1$...$b_m$. The term \lstinline{as 'smth} which constraints type variable \lstinline{'smth} to be equal to left hand side of type declaration is optional.

Values of type $t$ can be constructed using the constructors from type $\tau$, so the generic catamorphism will be the same:
\begin{lstlisting}
let nonrec gcata_t tr inh x = gcata_$\tau$ tr inh x
\end{lstlisting}
Where \lstinline{tr} is a transformation object, \lstinline{inh} is an initial inherited attribute and \lstinline{x} is the value being transformed.

Implementation of an interface class for \lstinline{t} is just an inheritance of  $\tau$'s interface class with right type parameters and arguments. We assume below that all types used on right hand side of the declaration of type \lstinline{t} are available in the scope where we declare a class, although it could be not true (see \autoref{sec:nonrecpitfalls} for details). The $\tau$'s interface class has a structure like
\begin{lstlisting}
class [$\overline{'a_i,'sa_i,'ia_i}$, $'inh$, $'self$, $'syn$] class_$\tau$ = object ... end
\end{lstlisting}
and derived interface class will have these implementation
% \begin{lstlisting}
% class [$\overline{'a_i,'sa_i,'ia_i}$, $'inh$, $'syn$] class_$t$ = object
%     inherit [ $'a_1, b_1['ia_i \gets \!'a_i], b_1['sa_i \gets \!'a_i]$
%             , ...
%             , $'a_m, b_m['ia_i \gets \!'a_i], b_m['sa_i \gets \!'a_i]$
%             'inh, 'syn] class_$\tau$
% end
% \end{lstlisting}
\begin{lstlisting}
class [$\overline{'a_i,'sa_i,'ia_i}$, $'inh$,  $'self$, $'syn$] class_$t$ = object
    inherit [ (3*m) type parameters, $'inh$,  $'self$, $'syn$] class_$\tau$ 
      $m ~transformation ~functions~for~type~parameters$
      ...
      $transformation ~function ~for ~self$
end
\end{lstlisting}
Let's deal with type parameters which are: 
\lstinline{m} types of inherited attributes, 
\lstinline{m} normal type parameters,
\lstinline{m} types of synthesized attributes. 
\begin{itemize}
 \item Every $i$-th inherited type parameter is a $b_i$ where every $a_i$ is replaced by the type of inherited attribute of type parameter $a_i$:  $b_i['ia_i \gets \!'a_i]$.
 \item Every $i$-th normal type paramater is just a type which was used as $i$-th argument of $\tau$ in $t$ declaration, i.e. $b_i$.
 \item Synthesized attributes are dealt in the same manner as inhnerited ones: $b_i['sa_i \gets \!'a_i]$.
\end{itemize}
We are also able to construct transformation functions for every $b_i$: 
\begin{itemize}
 \item For all named types we suppose that good transformation function with right arity is in scope.
 \item For all polymorphic type variables we will use transformation function passed as constructor's arguments for this class.
 \item There is no polymorphic type parameters that doesn't have transformation function because it contradicts typechecking process of type declaration because Haskell-style existentional types has another syntax in OCaml.
\end{itemize}

% \section{Corner Cases}
% \label{chap:pitfalls}
% 
% \subsection{Can't decide representation from RHS of type declaration}
% 
% \subsection{Types used in type declaration go out of scope}
% Случай \listinline{nonrec} типов.

\section{Four ways to add types to visitor classes}
Виды типизации методов класса:
\begin{enumerate}

 \item Monomorphic approach (visitors)
    \begin{lstlisting}
    method virtual  visit_'a : _
    method visit_container :
      'env . 'env -> 'a container -> ...
    \end{lstlisting}
    \begin{itemize}
    \item Pros: Не нужно генерировать аннотации типов, что упрощает генерацию.
    \item Cons: Некомпозициональны (ссылка на главу у Потье)
    \end{itemize}
    
  \item Polymorphic approach (visitors)
    \begin{lstlisting}
    method visit_container :
      'env 'a .
	('env -> 'a -> ...) ->
	'env -> 'a container -> ...
    \end{lstlisting}
    \begin{itemize}
    \item Pros: композиционность,  в отличие от (1).
    \item Pros: Функции, передаваясь в каждый метод явно, позволяют поддержать нерегулярные типы. 
    (Хотя остается вопрос, зачем тогда универсальная квантификация)
    \item Cons: Нужны явные аннотации типов.
    \item Cons: Не поддерживаются для fold в библиотеке visitors (похоже там что-то с типами, в никаких статьях про это вроде не писалось).
    \item Cons: В некоторых случаях генерируют код, не проходящий проверку типов
	  \begin{lstlisting}
	  type ('a,'b) t = Foo of 'a * 'b (* OK *)
	  type 'a t2 = ('a, int) t (* compilation error in generated code *)
	  \end{lstlisting}
	  или пример из руководства по библиотеке (глава 3.1 из \cite{visitors_manual})
	  \begin{lstlisting}
	  type expr = E of expr oexpr [@@unboxed]
	  [@@deriving visitors { variety = "map"; polymorphic = true }]
	  \end{lstlisting}
	  Для обеих примеров генерируемый код можно исправить руками, потерев унивесальные квантификации методов
    \end{itemize}
  \item Polymorphic apprach without universal quantification of methods
      \begin{lstlisting}
	method visit_container :
	    ('env -> 'a -> ...) ->
	    'env -> 'a container -> ...
    \end{lstlisting}
    \begin{itemize}
    \item Pros: Два примера выше начинают работать.
    \item Cons: Нельзя выразить gmap через fold (ссылка на главу Потье).
    \end{itemize}
    
  \item Подход библиотеки Generic Transformes: функции-трансформации для аргументов передаются явно при создании класса.
    \begin{itemize}
    \item Cons: не поддерживаются нерегулярные типы
    \item Можно выразить gmap через fold \href{https://github.com/Kakadu/gt-demo/blob/master/src/demo06.ml}{ссылка на код}.
    \end{itemize}    
\end{enumerate}

Виды типизации самого класса:
\begin{enumerate}
 \item À la Потье
 \begin{lstlisting}
 class ['self] classname = object (self: 'self) ... end
 \end{lstlisting}
    \begin{itemize}
    \item Pros: Кратко: только один типовый параметр
    \item Cons: Невозможно сгенерировать сигнатуру в файле интерфейса
    \item Cons: Не получится поддержать объединение полиморфных вариантов: там требуются аннотоации открытости (для этого у нас используется дополнительный параметр) которые в данном подходе нет возможности вставить.
    \end{itemize}
 

 \item À la GT
 \begin{lstlisting}
 class [$\overline{'a_i, 'ia_i, 'sa_i}$, $'inh$, $'syn$,$'extra$] classname = object ... end
 \end{lstlisting}
 \begin{itemize}
    \item Cons: Длиннее
    \item Pros: Сигнатура генерируется 
    \item Pros: Объединение полиморфных вариантов работает.
    \end{itemize}
 
\end{enumerate}

\section{Техничесие особенности GT}
Возможно, надо будет привести пример, что если совсем хочется использовать неподходящие типы, то можно абстрагироваться до:
\begin{lstlisting}
type ('a,'b) t = ('a -> 'b) $\tau$
\end{lstlisting}
И показать пример синтаксиса как указать кастомную функцию-трансформацию для преобразования типового параметра $\tau$.
 
\section{Open questions}
\begin{itemize}
 \item What is generic catamorphism for \lstinline{type 'a antiphantom = 'a}? 
\end{itemize}


%% Bibliography
%\bibliography{bibfile}

%% Appendix
%\appendix
%\section{Appendix}

Text of appendix \ldots


\end{document}
