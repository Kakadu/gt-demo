%% For double-blind review submission, w/o CCS and ACM Reference (max submission space)
\documentclass[acmsmall,review,anonymous]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
%% For double-blind review submission, w/ CCS and ACM Reference
%\documentclass[acmsmall,review,anonymous]{acmart}\settopmatter{printfolios=true}
%% For single-blind review submission, w/o CCS and ACM Reference (max submission space)
%\documentclass[acmsmall,review]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
%% For single-blind review submission, w/ CCS and ACM Reference
%\documentclass[acmsmall,review]{acmart}\settopmatter{printfolios=true}
%% For final camera-ready submission, w/ required CCS and ACM Reference
%\documentclass[acmsmall]{acmart}\settopmatter{}


%% Journal information
%% Supplied to authors by publisher for camera-ready submission;
%% use defaults for review submission.
\acmJournal{PACMPL}
\acmVolume{1}
\acmNumber{CONF} % CONF = POPL or ICFP or OOPSLA
\acmArticle{1}
\acmYear{2017}
\acmMonth{1}
\acmDOI{} % \acmDOI{10.1145/nnnnnnn.nnnnnnn}
\startPage{1}

%% Copyright information
%% Supplied to authors (based on authors' rights management selection;
%% see authors.acm.org) by publisher for camera-ready submission;
%% use 'none' for review submission.
\setcopyright{none}
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
%\setcopyright{rightsretained}
%\copyrightyear{2017}           %% If different from \acmYear

%% Bibliography style
\bibliographystyle{ACM-Reference-Format}
%% Citation style
%% Note: author/year citations are required for papers published as an
%% issue of PACMPL.
\citestyle{acmauthoryear}   %% For author/year citations


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Note: Authors migrating a paper from PACMPL format to traditional
%% SIGPLAN proceedings format must update the '\documentclass' and
%% topmatter commands above; see 'acmart-sigplanproc-template.tex'.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%% Some recommended packages.
\usepackage{booktabs}   %% For formal tables:
                        %% http://ctan.org/pkg/booktabs
\usepackage{subcaption} %% For complex figures with subfigures/subcaptions
                        %% http://ctan.org/pkg/subcaption

\usepackage{amsmath,amssymb}
\usepackage{listings}
\usepackage{amsmath,amssymb}

\def\backtick{\char18}

\lstdefinelanguage{ocaml}{
keywords={fresh, conde, let, begin, end, in, match, type, and, fun, function, try, with, when, class,
object, method, of, rec, repeat, until, while, not, do, done, as, val, inherit,
new, module, sig, deriving, datatype, struct, if, then, else, open, private, virtual, include, @type},
sensitive=true,
commentstyle=\small\itshape\ttfamily,
keywordstyle=\ttfamily\underbar,
identifierstyle=\ttfamily,
basewidth={0.5em,0.5em},
columns=fixed,
fontadjust=true,
literate={`}{$\backtick$}1 {->}{{$\to\;\;$}}3 {===}{{$\equiv$}}3 {=/=}{{$\not\equiv$}}3 {|>}{{$\triangleright$}}3,
morecomment=[s]{(*}{*)}
}

\lstset{
mathescape=true,
identifierstyle=\ttfamily,
keywordstyle=\bfseries,
commentstyle=\scriptsize\rmfamily,
basewidth={0.5em,0.5em},
fontadjust=true,
language=ocaml
}
\let\listinline\lstinline

\begin{document}

%% Title information
\title[Short Title]{Full Title}         %% [Short Title] is optional;
                                        %% when present, will be used in
                                        %% header instead of Full Title.
\titlenote{with title note}             %% \titlenote is optional;
                                        %% can be repeated if necessary;
                                        %% contents suppressed with 'anonymous'
\subtitle{Subtitle}                     %% \subtitle is optional
\subtitlenote{with subtitle note}       %% \subtitlenote is optional;
                                        %% can be repeated if necessary;
                                        %% contents suppressed with 'anonymous'


%% Author information
%% Contents and number of authors suppressed with 'anonymous'.
%% Each author should be introduced by \author, followed by
%% \authornote (optional), \orcid (optional), \affiliation, and
%% \email.
%% An author may have multiple affiliations and/or emails; repeat the
%% appropriate command.
%% Many elements are not rendered, but should be provided for metadata
%% extraction tools.

%% Author with single affiliation.
\author{First1 Last1}
\authornote{with author1 note}          %% \authornote is optional;
                                        %% can be repeated if necessary
\orcid{nnnn-nnnn-nnnn-nnnn}             %% \orcid is optional
\affiliation{
  \position{Position1}
  \department{Department1}              %% \department is recommended
  \institution{Institution1}            %% \institution is required
  \streetaddress{Street1 Address1}
  \city{City1}
  \state{State1}
  \postcode{Post-Code1}
  \country{Country1}                    %% \country is recommended
}
\email{first1.last1@inst1.edu}          %% \email is recommended

%% Author with two affiliations and emails.
\author{First2 Last2}
\authornote{with author2 note}          %% \authornote is optional;
                                        %% can be repeated if necessary
\orcid{nnnn-nnnn-nnnn-nnnn}             %% \orcid is optional
\affiliation{
  \position{Position2a}
  \department{Department2a}             %% \department is recommended
  \institution{Institution2a}           %% \institution is required
  \streetaddress{Street2a Address2a}
  \city{City2a}
  \state{State2a}
  \postcode{Post-Code2a}
  \country{Country2a}                   %% \country is recommended
}
\email{first2.last2@inst2a.com}         %% \email is recommended
\affiliation{
  \position{Position2b}
  \department{Department2b}             %% \department is recommended
  \institution{Institution2b}           %% \institution is required
  \streetaddress{Street3b Address2b}
  \city{City2b}
  \state{State2b}
  \postcode{Post-Code2b}
  \country{Country2b}                   %% \country is recommended
}
\email{first2.last2@inst2b.org}         %% \email is recommended


%% Abstract
%% Note: \begin{abstract}...\end{abstract} environment must come
%% before \maketitle command
\begin{abstract}
Text of abstract \ldots.
\end{abstract}


%% 2012 ACM Computing Classification System (CSS) concepts
%% Generate at 'http://dl.acm.org/ccs/ccs.cfm'.
\begin{CCSXML}
<ccs2012>
<concept>
<concept_id>10011007.10011006.10011008</concept_id>
<concept_desc>Software and its engineering~General programming languages</concept_desc>
<concept_significance>500</concept_significance>
</concept>
<concept>
<concept_id>10003456.10003457.10003521.10003525</concept_id>
<concept_desc>Social and professional topics~History of programming languages</concept_desc>
<concept_significance>300</concept_significance>
</concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Software and its engineering~General programming languages}
\ccsdesc[300]{Social and professional topics~History of programming languages}
%% End of generated code


%% Keywords
%% comma separated list
\keywords{datatype-generic programming, object-oriented programming, code reuse}
%% \keywords are mandatory in final camera-ready submission


%% \maketitle
%% Note: \maketitle command must come after title commands, author
%% commands, abstract environment, Computing Classification System
%% environment and commands, and keywords command.
\maketitle


%\section{Introduction}

%Text of paper \ldots


%% Acknowledgments
\begin{acks}                            %% acks environment is optional
                                        %% contents suppressed with 'anonymous'
  %% Commands \grantsponsor{<sponsorID>}{<name>}{<url>} and
  %% \grantnum[<url>]{<sponsorID>}{<number>} should be used to
  %% acknowledge financial support and will be used by metadata
  %% extraction tools.
  This material is based upon work supported by the
  \grantsponsor{GS100000001}{National Science
    Foundation}{http://dx.doi.org/10.13039/100000001} under Grant
  No.~\grantnum{GS100000001}{nnnnnnn} and Grant
  No.~\grantnum{GS100000001}{mmmmmmm}.  Any opinions, findings, and
  conclusions or recommendations expressed in this material are those
  of the author and do not necessarily reflect the views of the
  National Science Foundation.
\end{acks}

\section{Regularity and non-regularity}
In a regular datatype declaration, occurrences of the declared type on the right-hand
side  of  the  defining  equation  are  restricted  to  copies  of  the  left-hand  side,  so
the recursion  is "tail recursive"
\footnote{from http://www.cs.ox.ac.uk/richard.bird/online/BirdMeertens98Nested.pdf}.

For example the \lstinline{type ('a,'b) t = A | B of ('a, int) t} is non-regular and we need to use
\textit{polymorphic recursion} to iterate over it. Without explicit annotation the iteration
function will have the wrong type.
\begin{lstlisting}
# let rec iter: 'a 'b . ('a, 'b) t -> unit = function A -> () | B x -> iter x;;
val iter : ('a, 'b) t -> unit = <fun>
# let rec iter = function A -> () | B x -> iter x;;
val iter : ('a, int) t -> unit = <fun>
\end{lstlisting}
In that particular case unfolding can help to do what we want without explicit type annotations
\begin{lstlisting}
let rec iter = function A -> () | B x -> iter x;;
let iter = function A -> () | B x -> iter x;;
\end{lstlisting}

\section{Sorts of types}
% $\overline{remark~how~to~write~upper~line}$
% 
% \[
% \underbrace{u'-P(x)u^2-Q(x)u-R(x)}_{\text{=0, since~$u$ is a particular solution.}}
% I_{2,(\underbrace{\scriptstyle3,3,3,3,3}_5)}
% \]

\begin{lstlisting}
type ($a_1$, ..., $a_n$) typename =
  (* primitive ones *)
  | int | string | ...
  (* constructors of algebraic types *)
  | $C_1$ of $t_{11}$ * ... * $t_{1 n_1}$ | ... | $C_k$ of $t_{k1}$ * ... * $t_{k n_k}$
  (* tuples can be viewed as specific predefined constructors *)
  | ($t_1$, ..., $t_k$)
  (* polymorphic variants *)
  | [ `$C_1$ of $t_{11}$ * ... * $t_{1 n_1}$ | ... | `$C_k$ of $t_{k1}$ * ... * $t_{k n_k}$ ]
  (* type applications *)
  | ($t_1$, ..., $t_  
\end{lstlisting}


\section{What is being generated in general}

For every \lstinline{type ($a_1$, ..., $a_n$) t} we generate:
\begin{itemize}
  \item A class where methods correspond to constructor names. We will call it an \textit{interface class} for \lstinline{t}. For normal and poly variants implementation is strightforward. For other sorts of types call will be populated by inheritance
  \begin{lstlisting}
  class virtual [ $class~arguments$ ] class_t = object
    (* either *)
      (** for every constructor (of normal or poly variant) called
        * $C_i$ of $t_{i1}$ * ... * $t_{i n_1}$
        *)
      (* method virtual c_$C_i$: 'inh -> $t_{i1}$ -> ... ->  $t_{in}$ -> 'syn*)
      method virtual c_$C_i$: 'inh -> $curried~constructor~arguments$ -> 'syn
  end
  \end{lstlisting}
  For type application of type $\tau$ to the args $t_1$ ... $t_n$: 
  \begin{lstlisting}
  class virtual [ $class~arguments$ ] class_t = object
    inherit [$with~application\!-\!specific~arguments$] class_$\tau$
  end
  \end{lstlisting}

  For every $n$-parametric type ($n>=0$) there are $3*n+2$ \textit{class arguments}. They are:
    \begin{center}
        $\overline{a_i, sa_i, ia_i}$, $'inh$, $'syn$
    \end{center}
  where \begin{itemize}
          \item $a_i$ is an $i$-th paramter of the type being processed;
          \item $sa_i$ is a synthesized attribute for type parameter $a_i$;
          \item $ia_i$ is an inherited attribute for type parameter $a_i$;
          \item $'syn$ is a synthesized attribute for the whole type.
  \end{itemize}
  
  Although there some differences for type declarations that involve mutal recursion.
  
  \item A \textit{generic catamorphism} $gcata_t$ (for the type $t$ being processed) which will traverse the type and apply transformation. It is defined using pattern-matching for the variant types or as a composition with generic catamorphism $gcata_\tau$ if type $t$ is constructed as an application of type $\tau$.
  \item For every transformation method $tr$ a concrete class with transformation's implementation

  \begin{lstlisting}
  class [ $tr~class~arguments$ ] $tr$_t self $f\!a_1$ ... $f\!a_n$ = object
    inherit [ $inherited~class~arguments$ ] class_t
    (* implementation of virtual methods if any *)
  end
  \end{lstlisting}
  where \begin{itemize}
          \item transformation $self$ is a current transformation; class is defined in open recursion style and will receive it after tying the knot
          \item $f\!a_i$ of type \lstinline{$ia_i$ -> $a_i$ -> $sa_i$} are transformation functions for type parameters
          \item $sa_i$ is a synthesized attribute for type parameter $a_i$
          \item $ia_i$ is an inherited attribute for type parameter $a_i$
          \item $'syn$ is a synthesized attribute for the whole type
  \end{itemize}
% \bigskip
%   TODO by Kakadu: I have strong feeling that $fa_i$ should have type \lstinline{$ia_i$ -> $a_i$ -> $sa_i$}. Motivating example will be a formatter plugin with \lstinline{'inh=== '$ia_i$ === Format.formatter} and \lstinline{'syn==='$sa_i$ === unit}.
  \item For every transformation method $tr$ a function which takes transformations $f\!a_i$ for every type parameter $a_i$, and a value of type $t$ that will be transformed
\end{itemize}

\section{Construction blocks for a transformation function}
A class declaration for transformation method requires transformations of for parameters of type $(a_1,...,a_n) t$ that is being processed; these transformation functions will be passed as arguments of class's constructor.

For all types that was used in declaration of type $t$ we suppose that transformation functions are present in the scope where the type $t$ is declared. As we declare class for transformation object just after type declaration, these functions will be in scope of type declaration too.

For recursive type declarations it is required to call a transformation function for this type inside the class that represents a transformation and will be used to get this function. OCaml language doesn't allow declaring mutally recusive functions and classes, so we break the recursion by explicitly passing self-transformation as first of constructor's arguments. More precisely, if we have a recursive type 

\begin{lstlisting}
type ('a, 'b) alist = ...
type 'a list = ('a, 'a list) alist

class ['a, 'b] show_alist : 'self -> (unit -> 'a -> string) ->
                                      (unit -> 'b -> string) ->
  object
    method c_Cons : unit -> 'a -> 'b -> string
    method c_Nil  : unit -> string
  end
\end{lstlisting}

we add extra constructor argument \lstinline{self} to the declaration of class
\begin{lstlisting}
class ['a] show_list self fa = object
  inherit ['a, unit, string, unit, string] class_list
  inherit ['a, 'a list] show_alist "anything" fa self
end
\end{lstlisting}
and use this function to specify a transformation of second argument during instantiation of the class \lstinline{show_alist}.

\textbf{Note}. This \lstinline{self} argument is not admissable for nonrecursive types because we instantiate the class \lstinline{show_alist} by looking \textit{only} on application \lstinline{('a,'a list) alist} of this type in the definition of the type \lstinline{'a list}. This means that we know nothing about recursivity of the type \lstinline{('a,'b) alist} during the generation of transformations for the type \lstinline{'a list}.

This remark brings some complications when dealing with mutally recursive types \lstinline{$t_1$},...,\lstinline{$t_n$} where we need to declare two classes per every pair of type $t_i$ and transformation \lstinline{trans}. The first class \lstinline{trans_stub_$t_i$} for type \lstinline{$t_i$} will have $n-1$ extra constructor parameters for functional transformers that process types declared with \lstinline{$t_i$} recursively. Using this classes we can declare $n$ transformation functions for every type $t_i$. We abuse mutal recursion to make this transformation functions have the same interface that transformation functions for non-recursive types have. After declaring transformation functions we can declare transformation classes \lstinline{trans_$t_i$} with desired interface by partially applying constructors of \lstinline{trans_stub_$t_i$} to \lstinline{n-1} transformation functions.
  
For an example with mutal recursion see \href{https://github.com/Kakadu/gt-demo/blob/master/src/demo05mutal.ml}{demo05} in the repository.

\section{Creating transformations for type aliases}
Let us have
\begin{lstlisting}
type ($a_1$,...,$a_m$)$\tau$ = ...
class virtual [$\overline{'a_i,'sa_i,'ia_i}$, $'inh$, $'syn$] class_$\tau$ = object .. end
\end{lstlisting}
and want to generate transformations for the type
\begin{lstlisting}
type ($a_1$,...,$a_n$)t = ($b_1$,...,$b_m$)$\tau$ as 'smth
\end{lstlisting}
which is a \textit{type alias} of type $\tau$ with $m$ type arguments $b_1$...$b_m$. The term \lstinline{as 'smth} which constraints type variable \lstinline{'smth} to be equal to left hand side of type declaration is optional.

Values of type $t$ can be constructed using the constructors from type $\tau$, so the generic catamprphism will be the same:
\begin{lstlisting}
let rec gcata_t tr inh x = gcata_$\tau$ tr inh x
\end{lstlisting}
Where \lstinline{tr} is a transformation object, \lstinline{inh} is an initial inherited attribute and \lstinline{x} is the value being transformed.

Implementation of an interface class for \lstinline{t} is just an inheritance of  $\tau$'s interface class with right type parameters and arguments. We assume below that all types used on right hand side of the declaration of type \lstinline{t} are available in the scope where we declare a class, although it could be not true (see \autoref{chap:pitfalls} for details). The $\tau$'s interface class has a structure like
\begin{lstlisting}
class [$\overline{'a_i,'sa_i,'ia_i}$, $'inh$, $'syn$] class_$\tau$ = object..end
\end{lstlisting}
and derived interface class will have these implementation
% \begin{lstlisting}
% class [$\overline{'a_i,'sa_i,'ia_i}$, $'inh$, $'syn$] class_$t$ = object
%     inherit [ $'a_1, b_1['ia_i \gets \!'a_i], b_1['sa_i \gets \!'a_i]$
%             , ...
%             , $'a_m, b_m['ia_i \gets \!'a_i], b_m['sa_i \gets \!'a_i]$
%             'inh, 'syn] class_$\tau$
% end
% \end{lstlisting}
\begin{lstlisting}
class [$\overline{'a_i,'sa_i,'ia_i}$, $'inh$, $'syn$] class_$t$ = object
    inherit [ (3*m) type parameters, 'inh, 'syn] class_$\tau$ 
      transformation function for self
      ...
      m transformation functions for type parameters
end
\end{lstlisting}
Let's deal with type parameters which are: \lstinline{m} normal type parameters, \lstinline{m} types of inherited attributes, \lstinline{m} types of synthesized attributes. 
\begin{itemize}
 \item Every $i$-th normal type paramater is just a type which was used as $i$-th argument of $\tau$ in $t$ declaration, i.e. $b_i$.
 \item Every $i$-th inherited type parameter is a $b_i$ where every $a_i$ is replaced by associated type inherited attribute:  $b_i['ia_i \gets \!'a_i]$.
 \item The same logic is applied to synthesized attributes: $b_i['sa_i \gets \!'a_i]$.
\end{itemize}
We are also able to construct transformation functions for every $b_i$: 
\begin{itemize}
 \item For all named types we suppose that good transformation function with right arity is in scope.
 \item For allpolymorphic type variables we will use transformation function passed as constructor's arguments for this class.
 \item There is no polymorphic type parameters that doesn't have transformation function because it contradicts typechecking process of type declaration because Haskell-style existentional types has another syntax in OCaml.
\end{itemize}

\section{Corner Cases}
\label{chap:pitfalls}

\subsection{Can't decide representation from RHS of type declaration}

\subsection{Types used in type declaration go out of scope}

\section{xxx}
\begin{lstlisting}
   let rec append$^o$ x y xy =
     (x === nil ()) &&& (y === xy) |||
     (fresh (h t)
       (x === h % t) &&&
       (fresh (ty)
         (h % ty === xy) &&& (append$^o$ t y ty)
       )
     )

   let rec revers$^o$ a b =
     conde [
       (a === nil ()) &&& (b === nil ());
       (fresh (h t)
         (a === h % t) &&&
         (fresh (a')
           (append$^o$ a' !< h b) &&& (revers$^o$ t a')
         )
       )
     ]
\end{lstlisting}

%% Bibliography
%\bibliography{bibfile}

%% Appendix
%\appendix
%\section{Appendix}

Text of appendix \ldots


\end{document}
